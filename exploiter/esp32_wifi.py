import os
import shutil
import signal
import subprocess
import time
import serial
import time

from constants import RUN_LOG_PATH
from fuzzlog.fuzzlog import FuzzLog
from utils import ae_logger, clean_up_process

from .wdissector_exploiter import WDissectorExploiter


class ESP32WifiExploiter(WDissectorExploiter):
    def __init__(
        self,
        *,
        fuzzlog: FuzzLog,
        session_id: str,
        run_dir: str,
        target_port: str,
        target_hub_port: int,
        exploit_timeout: int,
        flooding_exploit_timeout: int,
        timeout_exploit_timeout: int,
    ) -> None:
        super().__init__(
            session_id=session_id,
            protocol="wifi",
            board="esp32",
            run_dir=run_dir,
            fuzzlog=fuzzlog,
        )
        self.target_port = target_port
        self.target_hub_port = target_hub_port

        self.exploit_timeout = exploit_timeout
        self.flooding_exploit_timeout = flooding_exploit_timeout
        self.timeout_exploit_timeout = timeout_exploit_timeout

    def run_exploit_once(
        self, exploit_name: str, exploit_path: str, target_crash_type: str
    ):
        """
        Sometimes ESP32 is not automatically connecting to access point and a restart of WDissector is needed.
        """
        # return crash_found, crash_identifier
        actual_timeout = self.exploit_timeout
        if target_crash_type == "timeout":
            actual_timeout = max(actual_timeout, self.timeout_exploit_timeout)
        if "flooding" in exploit_name:
            actual_timeout = max(actual_timeout, self.flooding_exploit_timeout)

        prev_dir = os.getcwd()
        os.chdir(self.run_dir)
        run_log_path = f"{RUN_LOG_PATH}/wifi/{exploit_name}.log"
        crash_triggered = False

        max_retry = 5
        for num_retried in range(max_retry):
            ae_logger.debug(f"Trial {num_retried+1}/{max_retry}")
            # restart ESP32 target
            try:
                subprocess.run(
                    f"/home/user/wdissector/3rd-party/uhubctl/uhubctls -a cycle -p {self.target_hub_port}",
                    shell=True,
                    stdout=subprocess.PIPE,
                )
                time.sleep(1)
                with serial.Serial(self.target_port, 115200) as wifi_ser:
                    wifi_ser.dtr = False
                    time.sleep(0.5)
                    wifi_ser.dtr = True
                    time.sleep(0.5)
            except:
                ae_logger.error(
                    f"Error when restart ESP32 target at hub port {self.target_hub_port}",
                    exc_info=True,
                )

            # clear WDissector logs
            shutil.rmtree(f"{self.run_dir}/logs/wifi_ap/", ignore_errors=True)

            try:
                cmd = f'echo "set +m && sudo bin/wifi_ap_fuzzer --exploit={exploit_name}" | script {run_log_path} --flush'
                ae_logger.info(f"Running command: '{cmd}'")
                p = subprocess.Popen(cmd, start_new_session=True, shell=True)
                time.sleep(1)
                log = open(run_log_path, "r", encoding="utf8", errors="ignore")
                is_compile_error = False
                is_timeout = False
                is_connected = False
                start = time.time()
                while True:
                    # Exploit execution timeout check
                    if time.time() - start > actual_timeout:
                        ae_logger.info("Exploit timeout.")
                        is_timeout = True
                        break
                    # WIFI connected timeout
                    if not is_connected and time.time() - start > 10:
                        # If ESP32 is still disconnected after 10 seconds, restart WDissector
                        # This is a special case for Wi-Fi target, though the tool can still run
                        # without this handle for special case.
                        break

                    line = log.readline()
                    if line == "":
                        time.sleep(0.3)
                        continue
                    elif "Interface initialization failed" in line:
                        # Retry initializing Wi-Fi interface
                        break
                    elif "wifi:connected" in line or "wifi:state" in line:
                        is_connected = True
                    elif (target_crash_type == "normal" and "Crash detected" in line) or (
                        target_crash_type == "timeout" and "[Timeout]" in line
                    ):
                        crash_triggered = True
                        # wait till all necessary logs are printed out
                        time.sleep(1)
                        break
                    elif "Error when loading or compiling C Modules" in line:
                        try:
                            os.remove(f"{self.exploit_folder}/{exploit_name}.so")
                            os.remove(f"{self.exploit_folder}/{exploit_name}.o")
                        except:
                            ae_logger.debug(
                                f"File {self.exploit_folder}/{exploit_name}.so/o does not exist."
                            )
                        is_compile_error = True
                        break

                if crash_triggered or is_timeout:
                    break
                if is_compile_error or not is_connected:
                    continue
            finally:
                os.killpg(os.getpgid(p.pid), signal.SIGTERM)
                clean_up_process(exploit_name)
        else:
            ae_logger.error(
                f"Exploit {exploit_name} fails to run after {max_retry} retries."
            )

        os.chdir(prev_dir)
        crash_identifier = ""
        if crash_triggered:
            crash_identifier = self.fuzzlog.get_crash_id(
                run_log_path, run_log_path, target_crash_type
            )

        return crash_triggered, crash_identifier
