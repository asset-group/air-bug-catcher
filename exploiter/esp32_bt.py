import os
import shutil
import signal
import subprocess
import time

from constants import RUN_LOG_PATH
from fuzzlog.fuzzlog import Crash, FuzzLog
from utils import ae_logger, clean_up_process, convert_bytes_to_cpp_array

from .wdissector_exploiter import WDissectorExploiter


class ESP32BtExploiter(WDissectorExploiter):
    def __init__(
        self,
        *,
        fuzzlog: FuzzLog,
        session_id: str,
        run_dir: str,
        host_port: str,
        target: str,
        target_port: str,
        target_hub_port: int,
        exploit_timeout: int,
        flooding_exploit_timeout: int,
        timeout_exploit_timeout: int,
    ) -> None:
        super().__init__(
            session_id=session_id,
            protocol="bt",
            board="esp32",
            run_dir=run_dir,
            fuzzlog=fuzzlog,
        )
        self.host_port = host_port
        self.target = target
        self.target_port = target_port
        self.target_hub_port = target_hub_port

        # TODO: this timeout should be in AutoExploiter, or not?
        self.exploit_timeout = exploit_timeout
        self.flooding_exploit_timeout = flooding_exploit_timeout
        self.timeout_exploit_timeout = timeout_exploit_timeout

    def run_exploit_once(
        self, exploit_name: str, exploit_path: str, target_crash_type: str
    ):
        # return crash_found, crash_identifier
        actual_timeout = self.exploit_timeout
        if target_crash_type == "timeout":
            actual_timeout = max(actual_timeout, self.timeout_exploit_timeout)
        if "flooding" in exploit_name:
            actual_timeout = max(actual_timeout, self.flooding_exploit_timeout)

        prev_dir = os.getcwd()
        os.chdir(self.run_dir)
        run_log_path = f"{RUN_LOG_PATH}/bt/{exploit_name}.log"
        crash_triggered = False

        max_retry = 3
        for num_retried in range(max_retry):
            ae_logger.debug(f"Trial {num_retried+1}/{max_retry}")
            # restart ESP32 target
            try:
                subprocess.run(
                    f"/home/user/wdissector/3rd-party/uhubctl/uhubctls -a cycle -p {self.target_hub_port}",
                    shell=True,
                    stdout=subprocess.PIPE,
                )
                time.sleep(2.5)
            except:
                ae_logger.error(
                    f"Error when restart ESP32 target at hub port {self.target_hub_port}",
                    exc_info=True,
                )

            # clear WDissector logs
            shutil.rmtree(f"{self.run_dir}/logs/Bluetooth/", ignore_errors=True)

            try:
                cmd = f'echo "set +m && sudo bin/bt_fuzzer --no-gui --host-port {self.host_port} --target-port {self.target_port} --target {self.target} --exploit={exploit_name}" | script {run_log_path} --flush'
                ae_logger.info(f"Running command: '{cmd}'")
                p = subprocess.Popen(cmd, start_new_session=True, shell=True)
                time.sleep(1)
                log = open(run_log_path, "r", encoding="utf8", errors="ignore")
                is_compile_error = False
                is_timeout = False
                start = time.time()
                while True:
                    if time.time() - start > actual_timeout:
                        ae_logger.info("Exploit timeout.")
                        is_timeout = True
                        break

                    line = log.readline()
                    if line == "":
                        time.sleep(0.3)
                        continue
                    elif (target_crash_type == "normal" and "Crash detected" in line) or (
                        target_crash_type == "timeout" and "[Timeout]" in line
                    ):
                        crash_triggered = True
                        # wait till all necessary logs are printed out
                        time.sleep(1)
                        break
                    elif "Error when loading or compiling C Modules" in line:
                        try:
                            os.remove(f"{self.exploit_folder}/{exploit_name}.so")
                            os.remove(f"{self.exploit_folder}/{exploit_name}.o")
                        except:
                            ae_logger.debug(
                                f"File {self.exploit_folder}/{exploit_name}.so/o does not exist."
                            )
                        is_compile_error = True
                        break

                if crash_triggered or is_timeout:
                    break
                if is_compile_error:
                    continue
            finally:
                os.killpg(os.getpgid(p.pid), signal.SIGTERM)
                clean_up_process(exploit_name)
        else:
            ae_logger.error(
                f"Exploit {exploit_name} fails to run after {max_retry} retries."
            )

        os.chdir(prev_dir)
        crash_identifier = ""
        if crash_triggered:
            crash_identifier = self.fuzzlog.get_crash_id(
                run_log_path, run_log_path, target_crash_type
            )

        return crash_triggered, crash_identifier

    def flood_script_generator(self, crash: Crash):
        for pkt in reversed(crash.fuzzed_pkts):
            if pkt.type == "mutation":
                continue
            if crash.iteration - pkt.iteration > 30:
                continue
            if pkt.state == "TX / LMP / LMP_detach":
                continue
            exploit_name = f"{self.exploit_prefix}ae_{self.protocol}_{self.board}_flooding_{pkt.loc}_{self.session_id}"
            exploit_path = f"{self.exploit_folder}/{exploit_name}.cpp"

            with open(exploit_path, "w", encoding="utf8") as f:
                f.write(
                    self.flood_exploit_template.substitute(
                        flooding_pkt=convert_bytes_to_cpp_array(pkt.pkt_bytes[4 + 7 : -1]),
                        pkt_state=pkt.state,
                    )
                )
            yield exploit_name, exploit_path
