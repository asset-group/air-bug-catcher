import os
import shutil
import signal
import subprocess
import time
import traceback

from constants import RUN_LOG_PATH
from fuzzlog.fuzzlog import FuzzLog
from utils import ae_logger, clean_up_process

from .wdissector_exploiter import WDissectorExploiter


class OnePlus5GExploiter(WDissectorExploiter):
    def __init__(
        self,
        *,
        session_id: str,
        run_dir: str,
        fuzzlog: FuzzLog,
        modem_timeout: int,
        exploit_timeout: int,
        flooding_exploit_timeout: int,
        timeout_exploit_timeout: int,
    ) -> None:
        super().__init__(
            session_id=session_id,
            protocol="5g",
            board="oneplus",
            run_dir=run_dir,
            fuzzlog=fuzzlog,
        )
        self.modem_timeout = modem_timeout
        self.exploit_timeout = (
            exploit_timeout  # TODO: this timeout should be in AutoExploiter, or not?
        )
        self.flooding_exploit_timeout = flooding_exploit_timeout
        self.timeout_exploit_timeout = timeout_exploit_timeout

    def clean_before_run(self):
        try:
            subprocess.check_output(
                [f"{self.run_dir}/3rd-party/adb/adb", "shell", "logcat", "-c"]
            )
        except:
            traceback.print_exc()
        # clear WDissector logs
        shutil.rmtree(f"{self.run_dir}/logs/5gnr_gnb/", ignore_errors=True)

    def run_exploit_once(
        self, exploit_name: str, exploit_path: str, target_crash_type: str
    ):
        # return crash_found, crash_identifier
        actual_timeout = self.exploit_timeout
        if target_crash_type == "timeout":
            actual_timeout = max(actual_timeout, self.timeout_exploit_timeout)
        if "flooding" in exploit_name:
            actual_timeout = max(actual_timeout, self.flooding_exploit_timeout)

        # Unlike ESP32, no need to restart phone because WDissector will toggle airplane mode
        prev_dir = os.getcwd()
        os.chdir(self.run_dir)
        run_log_path = f"{RUN_LOG_PATH}/5gnr_gnb/{exploit_name}.log"
        crash_triggered = False

        max_retry = 3
        for num_retried in range(max_retry):
            ae_logger.debug(f"Trial {num_retried+1}/{max_retry}")
            self.clean_before_run()

            try:
                cmd = f'echo "set +m && bin/lte_fuzzer --EnableSimulator=false --EnableMutation=false --EnableOptimization=false --exploit={exploit_name}" | script {run_log_path} --flush'
                ae_logger.info(f"Running command: '{cmd}'")
                p = subprocess.Popen(cmd, start_new_session=True, shell=True)
                time.sleep(1)
                log = open(run_log_path, "r", encoding="utf8", errors="ignore")
                is_compile_error = False
                is_timeout = False
                start = time.time()
                while True:
                    if time.time() - start > actual_timeout:
                        ae_logger.info("Exploit timeout.")
                        is_timeout = True
                        break
                    line = log.readline()
                    if line == "":
                        time.sleep(0.3)
                        continue
                    elif "Crash detected" in line:
                        crash_triggered = True
                        time.sleep(1)
                        break
                    elif "Error when loading or compiling C Modules" in line:
                        try:
                            os.remove(f"{self.exploit_folder}/{exploit_name}.so")
                            os.remove(f"{self.exploit_folder}/{exploit_name}.o")
                        except:
                            ae_logger.debug(
                                f"File {self.exploit_folder}/{exploit_name}.so/o does not exist."
                            )
                        is_compile_error = True
                        break

                if crash_triggered or is_timeout:
                    break
                if is_compile_error:
                    continue
            finally:
                os.killpg(os.getpgid(p.pid), signal.SIGTERM)
                clean_up_process(exploit_name)
        else:
            pass
            # logger.error(
            #     f"Exploit {exploit_name} fails to run after {max_retry} retries."
            # )

        os.chdir(prev_dir)
        crash_identifier = ""
        if crash_triggered:
            crash_identifier = "not_found"
            # 5G fuzzer generate and split logs into 10MB chunks
            monitor_log_idx = 1
            while True:
                if not os.path.exists(
                    f"{self.run_dir}/logs/5gnr_gnb/monitor.{monitor_log_idx}.txt"
                ):
                    break
                monitor_log_path = (
                    f"{self.run_dir}/logs/5gnr_gnb/monitor.{monitor_log_idx}.txt"
                )
                monitor_log_idx += 1

            crash_identifier = self.fuzzlog.get_crash_id(
                monitor_log_path, run_log_path, target_crash_type
            )

        return crash_triggered, crash_identifier
