#include "ModulesInclude.hpp"
#include <stdlib.h>
#include <stdio.h>
#include <inttypes.h>

// Filters

// Vars
typedef struct
{
    int length;
    unsigned char *data;
} my_p;

std::vector<my_p *> load_pkts()
{
    std::vector<my_p *> res;
    const char *filename = "<baseline_data_path>";
    FILE *fp;
    fp = fopen(filename, "rb");
    unsigned char length_hex[4];
    while (1)
    {
        int read_l = fread(length_hex, 1, 4, fp);
        if (read_l == 0)
        {
            break;
        }
        uint32_t length = (uint32_t)length_hex[0] |
                          (uint32_t)length_hex[1] << 8 |
                          (uint32_t)length_hex[2] << 16 |
                          (uint32_t)length_hex[3] << 24;

        unsigned char *pkt_data = (unsigned char *)malloc(length * sizeof(unsigned char));
        fread(pkt_data, 1, length, fp);
        my_p *temp = (my_p *)malloc(sizeof(my_p));
        temp->length = length;
        temp->data = pkt_data;
        res.push_back(temp);
    }
    printf("Length of packets: %u", res.size());
    return res;
}

std::vector<my_p *> my_pkts;
int my_pkts_ptr = 0;

// Setup
const char *module_name()
{
    return "Auto Exploiter";
}

int setup(wd_modules_ctx_t *ctx)
{
    // Change required configuration for exploit
    ctx->config->options.auto_start_program = true;
    ctx->config->bluetooth.disable_role_switch = false;
    ctx->config->bluetooth.bridge_hci = true;
    ctx->config->bluetooth.intercept_tx = true;
    ctx->config->bluetooth.lmp_sniffing = true;
    ctx->config->bluetooth.rx_bypass = true; // for baseline experiment
    ctx->config->bluetooth.rx_bypass_on_demand = false;
    ctx->config->fuzzing.packet_retry = false;
    ctx->config->fuzzing.enable_duplication = false;
    ctx->config->fuzzing.enable_mutation = false;

    // load_pcap();
    my_pkts = load_pkts();
    return 0;
}

// TX
int tx_pre_dissection(uint8_t *pkt_buf, int pkt_length, wd_modules_ctx_t *ctx)
{
    return 0;
}

int tx_post_dissection(uint8_t *pkt_buf, int pkt_length, wd_modules_ctx_t *ctx)
{

    my_p *p = my_pkts.at(my_pkts_ptr);

    for (int i = 0; i < pkt_length; i++)
    {
        if (9 + i >= p->length)
        {
            break;
        }
        pkt_buf[i] = p->data[9 + i];
    }

    my_pkts_ptr++;

    if (my_pkts_ptr >= my_pkts.size())
    {
        exit(0);
    }

    return 0;
}

// RX
int rx_pre_dissection(uint8_t *pkt_buf, int pkt_length, wd_modules_ctx_t *ctx)
{

    return 0;
}

int rx_post_dissection(uint8_t *pkt_buf, int pkt_length, wd_modules_ctx_t *ctx)
{
    return 0;
}