#include "ModulesInclude.hpp"
#include <stdlib.h>
#include <stdio.h>
#include <inttypes.h>


// Filters
// Filters
// wd_filter_t f1;
$wd_filters_declaration

// Vars
static uint counter = 0;

// Setup
const char *module_name()
{
    return "Auto Exploiter for ESP32";
}

int setup(wd_modules_ctx_t *ctx)
{

    // Change required configuration for exploit
    ctx->config->options.auto_start_program = true;
    ctx->config->bluetooth.disable_role_switch = false;
    ctx->config->bluetooth.bridge_hci = true;
    ctx->config->bluetooth.intercept_tx = true;
    ctx->config->bluetooth.lmp_sniffing = true;
    ctx->config->bluetooth.rx_bypass = false;
    ctx->config->bluetooth.rx_bypass_on_demand = false;
    ctx->config->fuzzing.enable_duplication = false;
    ctx->config->fuzzing.enable_mutation = false;

    // f1 = wd_filter("");
    $wd_filters_setup
    return 0;
}

// TX
int tx_pre_dissection(uint8_t *pkt_buf, int pkt_length, wd_modules_ctx_t *ctx)
{
    // wd_register_filter(ctx->wd, f1);
    $wd_filter_registration
    return 0;
}


int tx_post_dissection(uint8_t *pkt_buf, int pkt_length, wd_modules_ctx_t *ctx)
{

    // if (wd_read_filter(ctx->wd, f1 ))
    // {
    //     pkt_buf[] = ;
    //     wd_log_y("Send mutated packet now");
    //     return 1;
    // }
    $wd_filter_action

    return 0;
}

// RX
int rx_pre_dissection(uint8_t *pkt_buf, int pkt_length, wd_modules_ctx_t *ctx)
{
    return 0;
}

int rx_post_dissection(uint8_t *pkt_buf, int pkt_length, wd_modules_ctx_t *ctx)
{
    return 0;
}