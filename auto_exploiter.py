import time
from itertools import combinations
from string import Template

from capture_process import (
    BoardType,
    Crash,
    CypressCapture,
    ESP32Capture,
    FuzzedPacket,
    ProtocolType,
)
from utils import (
    calc_file_sha256,
    convert_packet_cpp_array,
    find_mutation_loc,
    logger,
    run_exploit,
)


class AutoExploiter:
    # capture and exploit logic should happen in this class
    def __init__(
        self,
        capture_path: str,
        protocol: ProtocolType,
        board: BoardType,
        *,
        use_cache: bool = True,
        esp32_log_path: str = "",
    ) -> None:
        if protocol == "bt":
            if board == "esp32":
                self.capture = ESP32Capture(capture_path, esp32_log_path, use_cache)
            elif board == "cypress":
                self.capture = CypressCapture(capture_path, use_cache)
            else:
                logger.error(
                    f"Auto Exploiter currently does not support {board} board."
                )
        elif protocol == "5g":
            pass
        else:
            logger.error(
                f"Auto Exploiter currently does not support {protocol} protocol."
            )

    def gen_exploit_script(self, trial_pkts: list[FuzzedPacket]):
        """
        [
        {"type": "dup", "filter":"xx", "data":"pkt_data"},
        {"type": "mut", "filter":"xx", "mutations":[ (offset, mutation), () ]}
        ]
        """

        # result = []
        # for pkt in trial_pkts:
        #     temp = {"type": pkt["type"]}
        #     if pkt["type"] == "mutation":
        #         # packet can be malformed after mutation, so use previous packet to generate label
        #         temp["filter"] = label_packets(pkt["prev_pkt"].packet_data)
        #         temp["mutations"] = find_mutation_loc(pkt["prev_pkt"], pkt["pkt"])
        #     elif pkt["type"] == "duplication":
        #         # Duplicated packets are the same as original, so just use the label from itself
        #         temp["filter"] = label_packets(pkt["pkt"].packet_data)
        #         # bluetooth offset 4 + 7, the last byte is checksum which can be ignored
        #         temp["data"] = pkt["pkt"].packet_data[4 + 7 : -1]
        #     result.append(temp)

        wd_filters_declaration = ""
        wd_filters_setup = ""
        wd_filter_registration = ""
        wd_filter_action = ""

        for idx, trial_pkt in enumerate(trial_pkts):
            wd_filters_declaration += f"wd_filter_t f{idx+1};\n"
            wd_filters_setup += f"""f{idx+1} = wd_filter("{trial_pkt.filter}");\n    """
            wd_filter_registration += f"wd_register_filter(ctx->wd, f{idx+1});\n    "

            action = ""
            if trial_pkt.type == "mutation":
                mutations = ""
                for mutation in find_mutation_loc(
                    trial_pkt.prev_packet_bytes, trial_pkt.packet_bytes
                ):
                    mutations += f"        pkt_buf[{mutation[0]}] = {mutation[1]};\n"
                action = (
                    f"if (wd_read_filter(ctx->wd, f{idx+1}) && counter == {idx} )"
                    "\n"
                    "    {"
                    "\n" + mutations + '        wd_log_y("Send mutated packet now");'
                    "\n"
                    f"        counter = {(idx+1)%len(trial_pkts)};"
                    "\n"
                    "        return 1;"
                    "\n"
                    "    }"
                    "\n"
                )
            elif trial_pkt.type == "duplication":
                if self.capture.protocol == "bt":
                    # bluetooth offset 4 + 7, the last byte is checksum which can be ignored
                    payload = trial_pkt.packet_bytes[4:7:-1]
                else:
                    payload = trial_pkt.packet_bytes
                    logger.error("Please implement this")
                action = (
                    f"if (wd_read_filter(ctx->wd, f{idx+1}) && counter == {idx} )"
                    "\n"
                    "    {"
                    "\n"
                    f"        static uint8_t packet[] = {convert_packet_cpp_array(payload)} ;"
                    "\n"
                    f"        m_send_packet(ctx, packet, {len(payload)}, 1);"
                    "\n"
                    '        wd_log_y("Sending duplicated packets now!!!");'
                    "\n"
                    f"        counter = {(idx+1)%len(trial_pkts)};"
                    "\n"
                    "    }"
                    "\n"
                )
            else:
                logger.error(f"Unknown fuzzed packet type: {trial_pkt.type}")

            wd_filter_action += action

        exploit_template = Template(
            open(
                "/home/user/wdissector/modules/auto-exploiter/exploit_templates/exploit_bt.cpp.template",
                "r",
                encoding="utf8",
            ).read()
        )

        return exploit_template.substitute(
            wd_filters_declaration=wd_filters_declaration,
            wd_filters_setup=wd_filters_setup,
            wd_filter_registration=wd_filter_registration,
            wd_filter_action=wd_filter_action,
        )

    def exploit_script_generator(
        self,
        same_crashes: list[Crash],
        exploit_max_fuzzed_pkts: int,
        min_trial_pkts: int,
        max_trial_iter: int,
        max_trial_time: int,
    ):
        # Traverse in reverse because we want to try exploits from the packets that are
        # closest to the crash, but no need to try too far packets.
        # Example for packets range defined by max_trial_iter
        # packet:          (i-2)-th iteration
        # packet:          (i-2)-th iteration
        # packet:          (i-1)-th iteration      -------\
        # packet:          (i-1)-th iteration             |
        # packet:          i-th iteration                 | >> max_trial_iter = 2
        # packet:          i-th iteration                 |
        # crash happens at i-th iteration          -------/
        # Sometimes the crash happens in a completely new iteration where no fuzzed packets are inside.
        # In this scenario, problem will arise if num_iterations_to_try is set to 1, i.e. trial_pkts
        # is empty. Intuitively, the fuzzed packets in the previous iterations must have caused the
        # crash. Thus, trial_pkts needs to contain a minimum amount of packets.
        # TODO: min_trial_pkts might not be enough, as trial_pkts may need to include all packets from
        # previous iteration in the scenario mentioned above.
        # What if trial_pkts contain too many packets?
        for crash in same_crashes:
            start_time = time.time()  # for every single crash in same_crashes
            trial_pkts: list[FuzzedPacket] = []
            for fuzzed_pkt in reversed(crash.fuzzed_pkts):
                if len(trial_pkts) > min_trial_pkts and (
                    crash.iteration - fuzzed_pkt.iter >= max_trial_iter
                ):
                    break
                trial_pkts.append(fuzzed_pkt)

            for num_fuzzed_pkts in range(1, exploit_max_fuzzed_pkts + 1):
                for comb in combinations(range(len(trial_pkts)), num_fuzzed_pkts):
                    if time.time() - start_time > max_trial_time:
                        logger.error(
                            f"Maximum trial time has reached for crash located at {crash.pkt_loc}."
                        )
                        return

                    selected_trial_pkts = [trial_pkts[i] for i in comb]
                    # TODO:
                    filename_suffix = "esp32"
                    exploit_script_name = f"bt_auto_fuzz_uni_{ '_'.join([str(i.loc) for i in selected_trial_pkts ]) }_w{num_fuzzed_pkts}_{filename_suffix}"
                    exploit_script = self.gen_exploit_script(selected_trial_pkts)
                    exploit_path = f"/home/user/wdissector2/modules/exploits/bluetooth/{exploit_script_name}.cpp"
                    with open(
                        exploit_path,
                        "w",
                        encoding="utf8",
                    ) as f:
                        f.write(exploit_script)
                    # time.sleep(1)  # for some reason, wait 1 second here
                    yield exploit_script_name, exploit_path

    def auto_exploit(
        self,
        same_crash_thresh: int,
        exploit_max_fuzzed_pkts: int,
        min_trial_pkts: int,
        max_trial_iter: int,
        max_trial_time: int,
        modem_timeout: int,
        exploit_timeout: int,
    ):
        self.capture.discover_capture_crashes()
        grouped_crashes = self.capture.group_crashes(same_crash_thresh)
        logger.debug("test2")
        exploit_result = {}
        for same_crashes in grouped_crashes:
            for exploit, exploit_path in self.exploit_script_generator(
                same_crashes,
                exploit_max_fuzzed_pkts,
                min_trial_pkts,
                max_trial_iter,
                max_trial_time,
            ):
                logger.debug("test3")
                if exploit_result.get(calc_file_sha256(exploit_path)) is not None:
                    exploit_crash_id = exploit_result.get(
                        calc_file_sha256(exploit_path)
                    )
                    if (
                        exploit_crash_id is not None
                        and self.capture.is_same_crash_identifier(
                            exploit_crash_id, same_crashes[0].reason, same_crash_thresh
                        )
                    ):
                        logger.info(
                            f"Same crash triggered for crashes {[item.pkt_loc for item in same_crashes]}."
                        )
                        break
                    continue
                log_path = f"/home/user/wdissector/modules/auto-exploiter/logs/bluetooth/{exploit}.log"
                # run
                logger.debug("test4")
                run_exploit(exploit, modem_timeout, exploit_timeout, log_path)
                logger.debug("test5")
                exploit_crash_id = self.capture.find_crash_identifier_from_run_log(
                    log_path
                )
                exploit_result[calc_file_sha256(exploit_path)] = exploit_crash_id
                # TODO: should always use same_crashes[0].reason ?
                if (
                    exploit_crash_id is not None
                    and self.capture.is_same_crash_identifier(
                        exploit_crash_id, same_crashes[0].reason, same_crash_thresh
                    )
                ):
                    logger.info(
                        f"Same crash triggered for crashes {[item.pkt_loc for item in same_crashes]}."
                    )
                    break


"""
                ESP32       Cypress
crash id        from log    using state
"""


AutoExploiter("", "bt", "cypress")
